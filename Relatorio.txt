Relatório sobre trabalho de Laborátorio de Programação - 2014

###########################
#-Grupo:                  #
#-Renato Lui Geh          #
#-Ricardo Lira da Fonseca #
#-Yan Soares Couto        #
###########################

------------------------FASE 1------------------------------
Ground control to Major Gubi: commencing countdown, report go-bi!

                           *     .--.
                                / /  `
               +               | |
                      '         \ \__,
                  *          +   '--'  *
                      +   /\
         +              .'  '.   *
                *      /======\      +
                      ;:.  _   ;
                      |:. (_)  |
                      |:.  _   |
            +         |:. (_)  |          *
                      ;:.      ;
                    .' \:.    / `.
                   / .-'':._.'`-. \
                   |/    /||\    \|
                 _..--"""````"""--.._
           _.-'``                    ``'-._
         -'                                '-

######################
1.Decisões Tomadas
######################

    Para fazer o trabalho, mesmo na fase inicial, nosso grupo se reuniu para discutir como
tratar vários aspectos do jogo.
	
	  Primeiramente utilizamos muitos das idéias básicas que definem o tipo e base do jogo:
		    -Uma nave que andaria em 3 dimensões
		    -Inimigos que atiram na nave
		    -Cenário que vai se deslocando com uma lista de inimigos
			      que se aproximam relativamente da nave

	  Logo no começo foi visto decisões sobre movimentos dos objetos dos jogo. Naves se moveriam
sempre para frente com uma velocidade que pode variar, e além disso se moveriam lateralmente
e verticalmente em relação à tela. Entretanto decidimos por praticidade fazer ela temporariamente
paralela ao "chão", ou seja angularmente o que variaria nela seria apenas o inicio do percurso
dos projéteis atirados. Logo a nave teria como características sua posição em coordenadas no
Cenário (x,y,z), uma velocidade e os valores de direção da "arma" acoplada nela.
	  Com essa decisão não teriamos de nos preocupar muito no inicio com colisões ou a nave "fugir"
da tela já que nos testes iniciais utilizamos apenas o terminal, sem nenhuma parte gráfica. Por
essa mesma razão de praticidade por enquanto só mudamos diretamente a posição x e y da nave,
sem nenhuma aceleração individual nessas cordenadas para o movimento, e não rotacionamos a nave
para facilitar a colisão.
	  Logo a direção "vetorial" será mais utilizada no tiros, que ao serem criados, terão sua
posição e direção definidas pelas iniciais da nave. Tiros tambpem foram decididos inicialmente
para serem pontos em vez de terem tamanhos 3D como inimigos ou a nave principal (novamente para
facilitar na hora de colisão nessa etapa de desenvolvimento).
    Tiros colidirão tanto com a nave quanto com os inimigos. Uma outra decisão tomada foi que
tiros que inimigos atiram podem destruir outros inimigos. Isso foi escolhido tanto por razões de
praticidade nos testes, como seria uma feature bacana no jogo, onde o próprio cenário é sujeito
a sua auto destruição. Em fases futuras isso será decidido se permanece no projeto final.
    Desta forma os tiros tem um valor de "vida" assim como inimigos e a nave principal. Se por
acaso ao desenvolver melhor o jogo certos tiros tiverem a habilidade de atravessar inimigos ou
objetos, a manipulação de sua vida para que não abaixe de 0 instantanemente seria útil.
    Sobre o Cenário decidimos da seguinte forma:
    O Cenário, chamado de Scene, é composto de partições, ditas Sections, por meio de uma lista
ligada do tipo FIFO. Essas partições são, por sua vez, compostas de um vetor posição (x, y, z),
um vetor dimensão (width, height, length) e uma lista de inimigos. Quando o jogador, que controla
a nave , entra em uma Section, a anterior é destruída, implicando na destruição dos inimigos
contidos na partição. Em seguida, nós criamos uma nova partição no final da lista de
partições presente em Scene.
    Cada Section, quando criada, constrói um número de inimigos gerado pseudo-aleatoriamente em
posições diferentes mas que estejam dentro do paralelepípedo gerado por (x, y, z) e
(width, height, length).


######################
2.Problemas
######################

	  O maior problema que tivemos foi ter atrasado muito para começar o projeto, e por culpa disso
tivemos que acelerar muito pra terminar a tempo, logo não só prejudicando o pensamento de ideias
boas para o projeto, como não podendo sofisticar a parte de testes e melhora-lo. Isso será algo
que mais focaremos em outras fases: Organização.


------------------------FASE 2------------------------------
This is ground control to Major Gubi, you've really made the grade!

       !
       !
       ^
      / \
     /___\
    |=   =|
    |     |
    |  G  |
    |  U  |
    |  B  |
    |  I  |
    |     |
    |  X  |
    |  X  |
    |     |
   /|##!##|\
  / |##!##| \
 /  |##!##|  \
|  / ^ | ^ \  |
| /  ( | )  \ |
|/   ( | )   \|
    ((   ))
   ((  :  ))
   ((  :  ))
    ((   ))
     (( ))
      ( )
       .
       .
       .

######################
1.Decisões Tomadas
######################

    Já tinhamos feito uma considerável parte da parte II na primeira parte, como o laço de execução e
já lidar com o input do usuário. Primeiramente nessa segunda parte começamos tirando os bugs residuais
da primeira fase (tiros explodiam sem colidir com nada, algumas coisas não estavam sendo deletadas, ...) 
e adicionando novas coisas que estavam faltando (nave e tiros colidem com inimigos, gravidade afeta os
tiros, ...).
    Percebemos que estava muito difícil jogar o jogo e perceber se o que estava acontecendo estava
correto sem nenhum feedback além de texto dizendo 'o tiro colidiu com o inimigo'. Logo decidimos já começar
fazer parte da visualização 3D do jogo.
    Inicialmente utilizamos um bule 3D para testar o OpenGL. Posteriormente colocamos a nave, tiros e inimigos
na tela, com as colisões funcionando, e já com uma implementação de mouse e teclado para o input do usuário.
    Decidimos deixar o movimento da nave independente da câmera do jogo, ou seja ela pode se mover
nos eixos X e Y sempre orientada para frente e com velocidade constante. A camerâ, controlada pelo mouse,
como definido na parte 1, muda a orientação da "arma da nave", ou seja a orientação que os tiros serão disparados.
Para poder testar colocamos temporariamente uma cruz como cursos para definir onde a nave está mirando.



######################
2.Problemas
######################
    
    Poder controlar a camera com o mouse foi um desafio, no começo ficou bem ruim, a distância da camera à nave
não era constante e parecia ruim, mas com um pouco de trabalho conseguimos melhorar, apesar de ter muito espaço
para aperfeiçoar. 
    Para imprimir texto na tela e ter uma interface adequada para o usuário, também tivemos várias complicações.



######################
3.Próxima Parte
######################
  
    Para a terceira parte do projeto, planejamos polir mais o jogo. Deixar os gráficos melhores (os cubos
atualmente dificultam a percepção de distância e orientação), colocar mais conteúdo (power ups, mais inimigos,
mais tiros, e o que mais vier a nossa cabeça), arrumar bugs e deixar o jogo mais fluído.w